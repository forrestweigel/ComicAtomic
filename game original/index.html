<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>


    var config = {
        type: Phaser.AUTO,
        width: 1000,
        height: 720,
        cardW: 375,
        cardH: 562.5,
        cardS: 0.21,
        scene: {
            preload: preload,
            create: create
        }
    };

    var game = new Phaser.Game(config);

    function preload ()
    {
        this.load.spritesheet("FFDeck", "/ComicAtomic/img/FFDeck.png", {frameWidth: config.cardW, frameHeight: config.cardH});
        this.load.spritesheet("MMDeck", "/ComicAtomic/img/FFDeck.png", {frameWidth: config.cardW, frameHeight: config.cardH});
        this.load.image('board', '/ComicAtomic/img/board2.png'); 
        this.load.image('discard', '/ComicAtomic/img/FFLogo.png');
        this.load.image('logo', '/ComicAtomic/img/logo.png'); 
    }

    function create ()
    {
       this.input.mouse.disableContextMenu();
       this.bk = this.add.image(500,360,'board');
       this.discard = this.add.text(930, 650, '$','Arial, 80, , , , , white');
       this.deck = Phaser.Utils.Array.NumberArray(0,28);
       this.hand = Array();
       this.energy = 0;

       this.die1 = this.add.text(930, 100, '','Arial, 80, , , , , white');
       this.die2 = this.add.text(930, 125, '','Arial, 80, , , , , white');
       this.die3 = this.add.text(930, 150, '','Arial, 80, , , , , white');
       this.die4 = this.add.text(930, 175, '','Arial, 80, , , , , white');
       
       this.board = 
       [
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
       ]

       for(x = 0; x < 5; x++)
       {
           this.hand[x] = null;
       }

       Phaser.Utils.Array.Shuffle(this.deck);
       this.cardIdx = 0;
       fillHand(this);
       setUp(this);
       endTurnBtn(this);
       rollButton(this)
       movement(this);
    }

    function movement(game)
    {
        game.input.on('drag', function (pointer, gameObject, dragX, dragY) {

        gameObject.x = dragX;
        gameObject.y = dragY;
        });

        game.input.on('dragend', function (pointer, gameObject)
        {
        if(checkOverlap(gameObject, game.discard) && gameObject.placed == false)
        {
            gameObject.destroy();
            game.hand[gameObject.val] = null;
            game.energy += 1;
            game.discard.text = game.energy;
                
            x = Math.round((originX) / 120);
            y = Math.round((originY) / 79);
            game.board[x - 2][y - 1] = 0;
        }

        else if(!checkOverlap(gameObject, game.bk))
        {
            gameObject.x = originX;
            gameObject.y = originY;
        }

        else 
        {
            game.hand[gameObject.val] = null;
            gameObject.placed = true;
            var x = Math.round((gameObject.x) / 120);
            var y = Math.round((gameObject.y) / 79);

            if(game.board[x - 2][y - 1] == 0)
            {
                game.board[x - 2][y - 1] = 1;
                gameObject.x = 120 * x - 40;
                gameObject.y = 79 * y + 4;
                
                x = Math.round((originX) / 120);
                y = Math.round((originY) / 79);
                game.board[x - 2][y - 1] = 0;
            }

            else
            {        
                gameObject.x = originX;
                gameObject.y = originY;
            }
        }
        });

        game.input.on('dragstart', function (pointer, gameObject)
        {
            originX = gameObject.x;
            originY = gameObject.y;
        });

        game.input.on('gameobjectdown', function (pointer, gameObject)
        {
            if(pointer.rightButtonDown())
            {
                console.log(gameObject.name)
                gameObject.health--;

                if(gameObject.health == 0)
                {
                    gameObject.destroy();
                    game.energy += 1;
                    game.discard.text = game.energy;
                        
                    x = Math.round((originX) / 120);
                    y = Math.round((originY) / 79);
                    game.board[x - 2][y - 1] = 0;
                }
            }
        });
    }

    function setUp(game)
    {
        var num;
        var x;
        var y;

        for(i = 0; i < 6; i++)
        {
            x = Math.floor(Math.random() * 5) + 2;
            y = Math.floor(Math.random() * 4) + 5;

            var card = game.add.image(0, 0, "FFDeck", i);
            card.setScale(config.cardS);
            card.angle += -90;

            game.board[x - 2][y - 1] = 1;
            var set = game.add.container((120 * x) - 40, (79 * y) + 4, [ card ]);
            
            set.name = i;
            set.placed = true;
            set.health = 2;

            set.setSize(card.width * config.cardS, card.height * config.cardS);

            set.setInteractive();

            game.input.setDraggable(set);
        }
    }

    function fillHand(game)
    {
        for(x = 0; x < 5; x++)
        {
            if(game.hand[x] == null)
            {
                var card = game.add.image(0, 0, "FFDeck", game.deck[game.cardIdx]);
                var originX = 0;
                var originY = 0;
                card.setScale(config.cardS);
                card.angle += -90;

                game.hand[x] = game.add.container(70, 290 + (90 * x), [ card ]);
                
                game.hand[x].name = game.deck[game.cardIdx];
                game.hand[x].val = x;
                game.hand[x].placed = false;
                game.hand[x].health = 2;
                game.cardIdx++;

                game.hand[x].setSize(card.width * config.cardS, card.height * config.cardS);

                game.hand[x].setInteractive();

                game.input.setDraggable(game.hand[x]);
            }
        }   
    }

    function checkOverlap(sp1, sp2)
    {
        var bounds1 = sp1.getBounds();
        var bounds2 = sp2.getBounds();   

        return Phaser.Geom.Intersects.RectangleToRectangle(bounds1, bounds2);
    }

    function endTurnBtn(game)
    {    
        var sprite = game.add.image(0, 0, 'logo').setScale(.1);
        var endBtn = game.add.container(930, 613, [ sprite ]);
            
        endBtn.setSize(sprite.width * .1, sprite.height * .1);

        endBtn.setInteractive();

        endBtn.on('pointerover', function () {

            sprite.setTint(0x7878ff);

        });

        endBtn.on('pointerout', function () {

            sprite.clearTint();

        });

        endBtn.on('pointerdown', function () {

            fillHand(game);

        });
    }

    function rollButton(game)
    {    
        var sprite = game.add.image(0, 0, 'logo').setScale(.1);
        var endBtn = game.add.container(930, 50, [ sprite ]);
            
        endBtn.setSize(sprite.width * .1, sprite.height * .1);

        endBtn.setInteractive();

        endBtn.on('pointerover', function () {

            sprite.setTint(0x7878ff);

        });

        endBtn.on('pointerout', function () {

            sprite.clearTint();

        });

        endBtn.on('pointerdown', function () 
        {
            game.die1.text = Math.floor(Math.random() * 6) + 1;
            game.die2.text = Math.floor(Math.random() * 6) + 1;
            game.die3.text = Math.floor(Math.random() * 6) + 1;
            game.die4.text = Math.floor(Math.random() * 6) + 1;
        });
    }
   
    </script>

</body>
</html>